<?xml version="1.0" encoding="utf-8"?>
<!--
////////////////////////////////////////////////////////////////////////////////
//
//  UCF COURSE DEVELOPMENT AND WEB SERVICES
//  Copyright 2009 UCF Course Development and Web Services
//  All Rights Reserved.
//
//  NOTICE: Course Development and Webservices prohibits the use of the
//  following code without explicit permission.  Permission can be obtained
//  from the New Media team at <newmedia@mail.ucf.edu>.
//
////////////////////////////////////////////////////////////////////////////////
-->
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%" minWidth="300" minHeight="300"
	creationComplete="{init()}" clipContent="false" styleName="crosswordBackground">
	<mx:UIComponent id="puzzle" height="100%" width="100%"/>
	<mx:ArrayCollection id="source" collectionChange="{/*remake()*/}"/>
	<mx:Script>
		<![CDATA[
		import materia.CreatorEvents;
		import materia.questionStorage.Question;
		import mx.graphics.ImageSnapshot;
		import mx.collections.ArrayCollection;
		import mx.controls.Alert;
		import puzzleDisplay.CrosswordPuzzleDisplay;
		protected static const TRACE_STRING:String = "CrosswordDisplay.mxml";
		public var words:Array;
		public var crosswordPreview:CrosswordPuzzleDisplay;
		private var puzzleHasGenerated:Boolean = false;
		private var displayingHistoryPuzzle:Boolean = false;
		/**
		 * 	The maximum number of puzzles to store in history
		 */
		private var _maxHistoryToStore:int = 4;
		[Bindable]
		public var puzzleHistory:ArrayCollection;
		/**
		 * 	When CrosswordDisplay is created draw the inital puzzle
		 */
		public function init():void
		{
			puzzleHistory = new ArrayCollection();
			words = new Array();
			for(var i:int =0; i< source.length; i++)
			{
				words.push(source[i].question);
			}
			var tt:int = puzzle.width;
			crosswordPreview = new CrosswordPuzzleDisplay(tt, tt);
			puzzle.addChild(crosswordPreview);
			words = crosswordPreview.buildPuzzle("temp", words);
			crosswordPreview.drawPuzzle(words);
			puzzleHasGenerated = true;
			this.dispatchEvent(new Event(CreatorEvents.ENABLE_PUBLISH, true));
		}
		public function loadPreBuiltPuzzle(proceedDraw:Boolean=true):void
		{
			// source will have been set with the pre-built puzzle data
			// this will load it up
			words = new Array();
			for(var i:int =0; i< source.length; i++)
			{
				words.push(source[i].question);
			}
			crosswordPreview.loadPreBuiltPuzzle("temp", words);
			crosswordPreview.drawPuzzle(words);
			crosswordPreview.buildPuzzle("temp", words);
			crosswordPreview.drawPuzzle(words);
		}
		public function get numWordsUsed():int
		{
			var result:int =0;
			for(var i:int =0; i< words.length; i++)
			{
				if(words[i].options.posSet == true)
				{
					result++;
				}
			}
			return result;
		}
		/**
		 * 	Called when generate puzzle button is clicked from CrosswordCreator
		 */
		public function generate(iteration:int=0):void
		{
			if(iteration > 25)
			{
				Alert.show('There are no other puzzle posibilities.');
				return;
			}
			var wordsUsed:* = crosswordPreview.buildPuzzle("temp", words);
			crosswordPreview.reDraw(words); // need to send reDraw the original words, not the ones returned by buildPuzzle
			puzzleHasGenerated = true;
			this.dispatchEvent(new Event(CreatorEvents.ENABLE_PUBLISH, true));
		}
		/**
		 * 	Is called whenever the word list is changed.
		 */
		public function remake():void
		{
			if(!displayingHistoryPuzzle)
			{
				this.storePuzzleToHistory();
			}
			words = new Array();
			for(var i:int =0; i< source.length; i++)
			{
				words.push(source[i].question);
			}
			if(puzzle == null) return;
			words = crosswordPreview.buildPuzzle("temp", words);
			crosswordPreview.drawPuzzle(words);
			puzzleHasGenerated = true;
			displayingHistoryPuzzle = false;
		}
		/**
		 * 	Will take care of adding the puzzle to history.
		 *
		 * 	Stores a screenshot of the puzzle, and the qset.
		 */
		public function storePuzzleToHistory():void
		{
			//don't store the first puzzle.
			if(!puzzleHasGenerated) return;
			// Matrix for the bitmap data manipulation.
			var mPage:Matrix = new Matrix();
			mPage.scale(.5, .5);
			//Grab a screenshot of the puzzle
			var imageBitMapData:BitmapData = ImageSnapshot.captureBitmapData(this, mPage);
			//close array we need.
			var clonedWords:Array = new Array;
			// copy array to a new array to pass to the qset.
			for(var i:int = 0; i < this.words.length; i++)
			{
				var originalQuestion:Question = this.words[i] as Question;
				var tempQuestion:Question = Question(originalQuestion).clone();
				clonedWords.push(tempQuestion);
			}
			puzzleHistory.addItem({thumb:new Bitmap(imageBitMapData), qset: clonedWords});
			if(puzzleHistory.length > _maxHistoryToStore)
			{
				puzzleHistory.removeItemAt(0);
			}
		}
		public function redrawFromHistory(words:Array):void
		{
			this.words = words;
			crosswordPreview.drawPuzzle(words);
		}
		/**
		 * 	TODO: Make this work!
		 *	Will compare two qsets to see if they are the same.
		 *
		 *	@param qset1 First qset
		 *	@param qset2 Second qset (from history)
		 *
		 *	@return Will return true if puzzles are the same. False if not
		 */
		private function puzzlesAreSame(qset1:Array, qset2:Array):Boolean
		{
			if(qset1.length != qset2.length)
			{
				return false;
			}
			for(var i:int = 0; i < qset1.length; i++)
			{
				if(qset1[i].posSet != qset2[i].posSet)
				{
					return false;
				}
				if(qset1[i].x != qset2[i].x)
				{
					return false;
				}
				if(qset1[i].y != qset2[i].y)
				{
					return false;
				}
				if(qset1[i].answers[0] != qset2[i].answers[0])
				{
					return false;
				}
				if(qset1[i].questions[0] != qset2[i].questions[0])
				{
					return false;
				}
			}
			return true;
		}
		]]>
	</mx:Script>
</mx:Canvas>